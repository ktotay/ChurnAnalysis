# -*- coding: utf-8 -*-
"""Churn_LojistikRegresyon.ipynb

Automatically generated by Colaboratory.

"""

import pandas as pd

"""# ***Veri Seti Kontrolü***"""

# Veri setini yükleme
df = pd.read_excel("Churn_PrePro.xlsx")

df.head()

df.dtypes

# Değişkenleri kırpma
!pip install scipy
from scipy.stats.mstats import winsorize
df["Uluslararasi_Konusma"] = winsorize(df["Uluslararasi_Konusma"], limits=[0.05, 0.05])
df["Odeme_Yontemi_Kredi_Kartı_Odeme"] = winsorize(df["Odeme_Yontemi_Kredi_Kartı_Odeme"], limits=[0.05, 0.05])
df["Cinsiyet_Erkek"] = winsorize(df["Cinsiyet_Erkek"], limits=[0.05, 0.05])
df["Medeni_Durum_Evli"] = winsorize(df["Medeni_Durum_Evli"], limits=[0.05, 0.05])

# Korelasyon matrisi yöntemine göre model için önemli olabilecek değişkenler
X = df[["Uluslararasi_Konusma", "Odeme_Yontemi_Kredi_Kartı_Odeme", "Cinsiyet_Erkek", "Medeni_Durum_Evli"]]
y = df["Churn_Hala_Müsteri"]

df[["Uluslararasi_Konusma", "Odeme_Yontemi_Kredi_Kartı_Odeme", "Cinsiyet_Erkek", "Medeni_Durum_Evli"]].value_counts()

"""# ***Lojistik Regresyon Modeli***

- Eğitim Seti ve Test Seti

- Model Eğitme

- Ortalama Performans Değeri(5-fold cross-validation)

- Eğitim ve Test Setleri için ROC Eğrisi ve Değerleri

- Accuracy, Precision, Recall, F1 Score Hesapları

- Karmaşıklık Matrisi
"""

# Veri seti, %70 eğitim seti ve %30 test seti olarak ayrıldı.
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)

from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_val_score

model = LogisticRegression()
# Modeli train seti üzerinden eğitme
model.fit(X_train, y_train)

# 5-fold cross-validation ile modelin performansını değerlendirme
scores = cross_val_score(model, X, y, cv=5)

# Ortalama performans değerini yazdırma
print("Ortalama performans değeri:", scores.mean())

from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# Eğitim seti üzerinde ROC eğrisi çizme
train_probs = model.predict_proba(X_train)[:, 1]
fpr_train, tpr_train, thresholds_train = roc_curve(y_train, train_probs)
roc_auc_train = auc(fpr_train, tpr_train)
plt.figure(figsize=(10, 6))
plt.plot(fpr_train, tpr_train, label="Eğitim Seti (AUC = %0.2f)" % roc_auc_train)

# Test seti üzerinde ROC eğrisi çizme
test_probs = model.predict_proba(X_test)[:, 1]
fpr_test, tpr_test, thresholds_test = roc_curve(y_test, test_probs)
roc_auc_test = auc(fpr_test, tpr_test)
plt.plot(fpr_test, tpr_test, label="Test Seti (AUC = %0.2f)" % roc_auc_test)
plt.plot([0, 1], [0, 1], "k--")
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Eğrisi")
plt.legend(loc="lower right")
plt.show()

# Veri setinde dengesizlik var. Bu yüzden F1 skoru üzerinden yorum yapılır

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Eğitim setindeki tahminleri alma
train_preds = model.predict(X_train)

# Performans ölçümlerini hesaplama
accuracy = accuracy_score(y_train, train_preds)
precision = precision_score(y_train, train_preds)
recall = recall_score(y_train, train_preds)
f1 = f1_score(y_train, train_preds)

print("Accuracy: ", accuracy)
print("Precision: ", precision)
print("Recall: ", recall)
print("F1 Score: ", f1)

from sklearn.metrics import classification_report
print(classification_report(y_test, y_pred))

from sklearn.metrics import confusion_matrix
import seaborn as sns
y_pred = model.predict(X_test)

# Karmaşıklık matrisini hesapla
conf_mat = confusion_matrix(y_test, y_pred)

# Karmaşıklık matrisini ısı haritası olarak görselleştir
Karmasiklik_Matrisi = pd.DataFrame(conf_mat, columns=["Tahmin edilen_D", "Tahmin edilen_Y"], index=["Gercek_D", "Gercek_Y"])
print(Karmasiklik_Matrisi)
sns.heatmap(conf_mat, annot=True, cmap="Blues")

# Modeli daha iyi sonuç verdiği için Karmaşıklık Matrisi yöntemi kullanılmıştır.
# Modelde aykırı değerler performansı düşürmemesi için "Winsorization" methodu ile kırpılmıştır. 
# Genel olarak daha fazla veri, veri seti için daha iyi bir önişleme ile bu sorunların çözüleceğini düşünüyorum. Tabi ki farklı methodlarda 
# denenebilir.
# Veri seti dengesiz olduğu için modelin son halinde F1 skoru üzerinden yorum yapmak iyi olacaktır.